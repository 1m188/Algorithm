/**
 * @file L2-036 网红点打卡攻略.cpp
 * @date 2022-06-19
 */

/*
一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。

输入格式：
首先第一行给出两个正整数：网红点的个数 N（1<N≤200）和网红点之间通路的条数 M。随后 M 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 N 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 0。

再下一行给出一个正整数 K，是待检验的攻略的数量。随后 K 行，每行给出一条待检攻略，格式为：

n V 
1
​
  V 
2
​
  ⋯ V 
n
​
 

其中 n(≤200) 是攻略中的网红点数，V 
i
​
  是路径上的网红点编号。这里假设你从家里出发，从 V 
1
​
  开始打卡，最后从 V 
n
​
  回家。

输出格式：
在第一行输出满足要求的攻略的个数。

在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。

题目保证至少存在一个有效攻略，并且总路费不超过 10 
9
 。

输入样例：
6 13
0 5 2
6 2 2
6 0 1
3 4 2
1 5 2
2 5 1
3 1 1
4 1 2
1 6 1
6 3 2
1 2 1
4 5 3
2 0 2
7
6 5 1 4 3 6 2
6 5 2 1 6 3 4
8 6 2 1 6 3 4 5 2
3 2 1 5
6 6 1 3 4 5 2
7 6 2 1 3 4 5 2
6 5 2 1 4 3 6
输出样例：
3
5 11
样例说明：
第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。

第 1 条攻略的总路费是：(0->5) 2 + (5->1) 2 + (1->4) 2 + (4->3) 2 + (3->6) 2 + (6->2) 2 + (2->0) 2 = 14；

第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 = 11，是一条更省钱的攻略；

第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 = 11，与第 5 条花费相同，但序号较大，所以不输出。

代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB
*/

/* 图的模拟题，注意判断要求时候的细节 */

#include <cstdio>
#include <vector>
using namespace std;

int n = 0, m = 0;
vector<vector<int>> g;
int num = 0, cost = 1e9 + 1, cnt = 0;

bool judge(const vector<int> &vec) {
    vector<bool> flags(n + 1);
    for (const auto &e : vec) { // 如有重复访问则不行
        if (!flags[e])
            flags[e] = true;
        else
            return false;
    }
    for (int i = 1; i <= n; i++) // 如有节点没访问到则不行
        if (!flags[i]) return false;
    if (g[0][vec[0]] == 0 || g[vec.back()][0] == 0) return false; // 如首尾节点不能回家则不行
    for (int i = 1; i < vec.size(); i++)                          // 如中间某些节点不能顺序访问到下一个节点则不行
        if (g[vec[i - 1]][vec[i]] == 0) return false;
    return true;
}

int main() {

    // 输入图
    scanf("%d %d", &n, &m);
    g.resize(n + 1, vector<int>(n + 1));
    while (m--) {
        int a = 0, b = 0, c = 0;
        scanf("%d %d %d", &a, &b, &c);
        g[a][b] = g[b][a] = c;
    }

    int k = 0;
    scanf("%d", &k);
    for (int i = 1; i <= k; i++) {
        int u = 0;
        scanf("%d", &u);
        vector<int> vec(u);
        for (int j = 0; j < u; j++)
            scanf("%d", &vec[j]);

        if (!judge(vec)) continue;

        cnt++; // 计数

        int c = g[0][vec[0]]; // 当前攻略花费
        for (int j = 1; j < u; j++)
            c += g[vec[j - 1]][vec[j]];
        c += g[vec.back()][0];

        if (c < cost) { // 与最小花费比较
            cost = c;
            num = i;
        }
    }

    printf("%d\n%d %d", cnt, num, cost);

    return 0;
}