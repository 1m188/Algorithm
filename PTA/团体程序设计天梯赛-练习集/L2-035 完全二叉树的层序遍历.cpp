/**
 * @file L2-035 完全二叉树的层序遍历.cpp
 * @date 2022-06-17
 */

/*
一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是完美二叉树。对于深度为 D 的，有 N 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 N 个结点，这样的树就是完全二叉树。

给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。

输入格式：
输入在第一行中给出正整数 N（≤30），即树中结点个数。第二行给出后序遍历序列，为 N 个不超过 100 的正整数。同一行中所有数字都以空格分隔。

输出格式：
在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。

输入样例：
8
91 71 2 34 10 15 55 18
输出样例：
18 34 55 71 2 10 15 91
代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB
*/

/* 挺有意思，因为是完全二叉树，所以不必担心会有某个空节点，如果有空节点那么后面
必定都是空节点，或者说就到此为止了，所以用数组存储，而且也方便求取子节点，将后序遍历
中的元素都输入到该输入的地方，递归输入，模仿后续遍历的输入，输出的结果就是一颗完全二叉树，
完全二叉树的数组存储就是完全二叉树的层序遍历 */

#include <cstdio>
#include <vector>
using namespace std;

vector<int> vec;
int n = 0;

void create(int x = 0) {
    if (x >= n) return;
    create(x * 2 + 1);
    create(x * 2 + 2);
    scanf("%d", &vec[x]);
}

int main() {

    scanf("%d", &n);
    vec.resize(n);
    create();
    printf("%d", vec[0]);
    for (int i = 1; i < n; i++)
        printf(" %d", vec[i]);

    return 0;
}