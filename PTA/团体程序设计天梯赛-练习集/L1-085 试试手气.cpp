/**
 * @file L1-085 试试手气.cpp
 * @date 2022-05-21
 */

/*
sz.png
我们知道一个骰子有 6 个面，分别刻了 1 到 6 个点。下面给你 6 个骰子的初始状态，即它们朝上一面的点数，让你一把抓起摇出另一套结果。假设你摇骰子的手段特别精妙，每次摇出的结果都满足以下两个条件：

1、每个骰子摇出的点数都跟它之前任何一次出现的点数不同；
2、在满足条件 1 的前提下，每次都能让每个骰子得到可能得到的最大点数。
那么你应该可以预知自己第 n 次（1≤n≤5）摇出的结果。

输入格式：
输入第一行给出 6 个骰子的初始点数，即 [1,6] 之间的整数，数字间以空格分隔；第二行给出摇的次数 n（1≤n≤5）。

输出格式：
在一行中顺序列出第 n 次摇出的每个骰子的点数。数字间必须以 1 个空格分隔，行首位不得有多余空格。

输入样例：
3 6 5 4 1 4
3
输出样例：
4 3 3 3 4 3
样例解释：
这 3 次摇出的结果依次为：

6 5 6 6 6 6
5 4 4 5 5 5
4 3 3 3 4 3
代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB
*/

#include <cstdio>
using namespace std;

int main() {

    int flags[6]{0};
    for (int i = 0; i < 6; i++)
        scanf("%d", &flags[i]);

    int n = 0;
    scanf("%d", &n);

    int ans[6]{6, 6, 6, 6, 6, 6};
    for (int i = 0; i < 6; i++) {
        if (ans[i] == flags[i])
            ans[i]--;
    }
    n--;

    while (n--) {
        for (int i = 0; i < 6; i++) {
            ans[i]--;
            if (ans[i] == flags[i])
                ans[i]--;
        }
    }

    printf("%d", ans[0]);
    for (int i = 1; i < 6; i++)
        printf(" %d", ans[i]);

    return 0;
}