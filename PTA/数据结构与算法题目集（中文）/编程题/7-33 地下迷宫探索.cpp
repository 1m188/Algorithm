/**
 * @file 7-33 地下迷宫探索.cpp
 * @date 2022-05-12
 */

/*
地道战是在抗日战争时期，在华北平原上抗日军民利用地道打击日本侵略者的作战方式。
地道网是房连房、街连街、村连村的地下工事，如下图所示。



我们在回顾前辈们艰苦卓绝的战争生活的同时，真心钦佩他们的聪明才智。
在现在和平发展的年代，对多数人来说，探索地下通道或许只是一种娱乐或者益智的游戏。
本实验案例以探索地下通道迷宫作为内容。

假设有一个地下通道迷宫，它的通道都是直的，而通道所有交叉点（包括通道的端点）上都有一盏灯和一个开关。
请问你如何从某个起点开始在迷宫中点亮所有的灯并回到起点？



输入格式:
输入第一行给出三个正整数，分别表示地下迷宫的节点数N（1<N≤1000，表示通道所有交叉点和端点）、
边数M（≤3000，表示通道数）和探索起始节点编号S（节点从1到N编号）。随后的M行对应M条边（通道），
每行给出一对正整数，分别是该条边直接连通的两个节点的编号。

输出格式:
若可以点亮所有节点的灯，则输出从S开始并以S结束的包含所有节点的序列，序列中相邻的节点一定有边（通道）；
否则虽然不能点亮所有节点的灯，但还是输出点亮部分灯的节点序列，最后输出0，此时表示迷宫不是连通图。

由于深度优先遍历的节点序列是不唯一的，为了使得输出具有唯一的结果，
我们约定以节点小编号优先的次序访问（点灯）。
在点亮所有可以点亮的灯后，以原路返回的方式回到起点。

输入样例1:
6 8 1
1 2
2 3
3 4
4 5
5 6
6 4
3 6
1 5

输出样例1:
1 2 3 4 5 6 5 4 3 2 1

输入样例2:
6 6 6
1 2
1 3
2 3
5 4
6 5
6 4

输出样例2:
6 4 5 4 6 0

代码长度限制
16 KB

时间限制
400 ms

内存限制
64 MB
*/

/* dfs遍历从起始节点遍历全图，注意要记录路径包括退回来的路径 */

#include <iostream>
#include <vector>
using namespace std;

int N = 0,                  // 节点数
    M = 0,                  // 边数
    S = 0;                  // 起始节点
vector<vector<bool>> graph; // 邻接矩阵图
vector<bool> flags;         // dfs所用的访问标志位
vector<int> path;           // 最终结果路径

/**
 * @brief 处理输入，构建图
 */
void input() {
    cin >> N >> M >> S;

    graph.resize(N + 1, vector<bool>(N + 1));
    flags.resize(N + 1);

    while (M--) {
        int a = 0, b = 0;
        cin >> a >> b;
        graph[a][b] = graph[b][a] = true;
    }
}

/**
 * @brief 从起始节点递归dfs遍历全图
 * @param n 当前待访问节点
 */
void dfs(int n = S) {
    flags[n] = true;   // 访问节点
    path.push_back(n); // 加入路径

    // 对每个没访问过的节点进行访问，注意退出来之后
    // 要记得再加入本节点，作为路径又退回本节点
    for (int i = 1; i <= N; i++) {
        if (graph[n][i] && !flags[i]) {
            dfs(i);
            path.push_back(n);
        }
    }
}

/**
 * @brief 输出
 */
void print() {
    // 检查是否遍历所有节点
    for (int i = 1; i <= N; i++)
        if (!flags[i]) {
            path.push_back(0);
            break;
        }

    // 输出最终结果
    cout << path[0];
    for (int i = 1; i < path.size(); i++)
        cout << ' ' << path[i];
}

int main() {
    input();
    dfs();
    print();
    return 0;
}