/**
 * @file 7-25 朋友圈.cpp
 * @date 2022-05-08
 */

/*
某学校有N个学生，形成M个俱乐部。每个俱乐部里的学生有着一定相似的兴趣爱好，形成一个朋友圈。
一个学生可以同时属于若干个不同的俱乐部。
根据“我的朋友的朋友也是我的朋友”这个推论可以得出，如果A和B是朋友，且B和C是朋友，则A和C也是朋友。
请编写程序计算最大朋友圈中有多少人。

输入格式:
输入的第一行包含两个正整数N（≤30000）和M（≤1000），分别代表学校的学生总数和俱乐部的个数。
后面的M行每行按以下格式给出1个俱乐部的信息，其中学生从1~N编号：

第i个俱乐部的人数Mi（空格）学生1（空格）学生2 … 学生Mi

输出格式:
输出给出一个整数，表示在最大朋友圈中有多少人。

输入样例:
7 4
3 1 2 3
2 1 4
3 5 6 7
1 6

输出样例:
4

代码长度限制
16 KB

时间限制
400 ms

内存限制
64 MB
*/

/* 并查集
所谓并查集指的是这种集合，一般是一个数组，每个索引代表一个节点，而该索引下数组的值则代表
该节点的父节点索引，一直到如果没有父节点的话，则该索引下的值为该索引本身。
对于并查集，这里用了两个比较重要的函数操作，一个是find，找到该索引代表节点最终的根；一个是
merge，将两个节点合并到一个根下。同时在find的过程中还使用了路径压缩。 */

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int N = 0,       // 学生人数
    M = 0;       // 俱乐部数量
vector<int> vec; // 并查集

/**
 * @brief 对于并查集找到该节点的根节点
 * @param x 该节点索引
 * @return int 根节点索引
 */
int find(int x) {
    if (vec[x] == x) // 如果该节点的父节点就是自己，说明是根节点，直接返回
        return x;
    else {

        // 这里是路径压缩，很重要。
        // 对于一个节点，从他到他的根节点可能要经过很长的距离，这里用递归的形式
        // 将这个节点的父节点指到他的根节点上去，再次查找的时候就不用递归那么多层了
        // 由于这一题的并查集是求一个集合，因此只要保持节点联系即可，不必保持先后顺序
        vec[x] = find(vec[x]);
        return vec[x]; // 返回根节点
    }
}

/**
 * @brief 合并两个节点的根节点
 * @param x 待合并节点x
 * @param y 待合并节点y
 */
void merge(int x, int y) {
    int rx = find(x), ry = find(y); // 找到两个节点的根节点
    vec[ry] = rx;                   // 把其中一个根节点的父节点指向另一个根节点
}

/**
 * @brief 初始化输入
 */
void input() {
    cin >> N >> M;
    vec.resize(N + 1);
    for (int i = 1; i <= N; i++)
        vec[i] = i;
    while (M--) {
        int n = 0;
        cin >> n;
        int stu = 0; // 这里拿到每个俱乐部第一个人，作为这个俱乐部的根
        cin >> stu;
        n--;
        while (n--) { // 其他人都连到这个根上去
            int t = 0;
            cin >> t;
            merge(t, stu);
        }
    }
}

/**
 * @brief 计算结果
 * @return int 返回最终结果
 */
int calc() {
    vector<int> ans(N + 1);

    for (int i = 1; i <= N; i++) {

        /* 对于每个节点，找到他的根，在数组根索引的值上+1，
        在这里的find中，每个节点都会直接指向他的最终根节点，
        并且对于分叉之类的情况可以起到很好的节省再次查找时间
        的作用 */
        ans[find(i)]++;
    }

    return *max_element(ans.begin(), ans.end());
}

int main() {
    input();
    cout << calc();
    return 0;
}