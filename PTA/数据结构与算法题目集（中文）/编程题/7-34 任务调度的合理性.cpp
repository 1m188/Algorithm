/**
 * @file 7-34 任务调度的合理性.cpp
 * @date 2022-05-12
 */

/*
假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。
“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。

比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。
有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；
有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。

但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。
比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，
那么这三个任务哪个都不能先执行，这就是一个不可行的方案。
你现在的工作是写程序判定任何一个给定的任务调度是否可行。

输入格式:
输入说明：输入第一行给出子任务数N（≤100），子任务按1~N编号。随后N行，每行给出一个子任务的依赖集合：
首先给出依赖集合中的子任务数K，随后给出K个子任务编号，整数之间都用空格分隔。

输出格式:
如果方案可行，则输出1，否则输出0。

输入样例1:
12
0
0
2 1 2
0
1 4
1 5
2 3 6
1 3
2 7 8
1 7
1 10
1 7

输出样例1:
1

输入样例2:
5
1 4
2 1 4
2 2 5
1 3
0

输出样例2:
0

代码长度限制
16 KB

时间限制
400 ms

内存限制
64 MB
*/

/* 拓扑排序判断有向图是否有环 */

#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int N = 0;                 // 节点数
vector<int> in;            // 每个节点的入度
vector<vector<int>> edges; // 每个节点的所有后继节点

/**
 * @brief 初始化输入
 */
void input() {
    cin >> N;
    in.resize(N + 1);
    edges.resize(N + 1);

    for (int i = 1; i <= N; i++) {
        int K = 0;
        cin >> K;
        in[i] += K; // 当前任务依赖K个任务，则其入度+K

        while (K--) {
            int a = 0;
            cin >> a;
            edges[a].push_back(i); // 当前任务依赖其他任务，即其他任务导向该任务
        }
    }
}

/**
 * @brief 判断是否能够成功调度
 * @return true 是
 * @return false 否
 */
bool judge() {
    int num = 0; // 判断是否遍历过所有节点

    queue<int> que;
    for (int i = 1; i <= N; i++) // 先将所有入度==0的节点入队
        if (!in[i]) {
            que.push(i);
            num++;
        }

    /* 遍历队列中所有元素，每个节点都是入度为零，将其从图中删去，
    则其所指向节点的入度也都要-1，此时如果有新的入度为零的节点出现，
    也必然是这些节点 */
    while (!que.empty()) {
        int v = que.front();
        que.pop();

        for (const auto &e : edges[v]) {
            if (!--in[e]) {
                que.push(e);
                num++; // 记得计数遍历节点
            }
        }
    }

    // 拓扑排序之后判断是否遍历过所有节点
    return num == N;
}

int main() {
    input();
    cout << judge();
    return 0;
}