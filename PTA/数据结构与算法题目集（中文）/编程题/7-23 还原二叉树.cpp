/**
 * @file 7-23 还原二叉树.cpp
 * @brief 给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。
 * @date 2022-05-08
 */

/*
给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。

输入格式:
输入首先给出正整数N（≤50），为树中结点总数。
下面两行先后给出先序和中序遍历序列，均是长度为N的不包含重复英文字母（区别大小写）的字符串。

输出格式:
输出为一个整数，即该二叉树的高度。

输入样例:
9
ABDFGHIEC
FDHGIBEAC

输出样例:
5

代码长度限制
16 KB

时间限制
400 ms

内存限制
64 MB
*/

/*  例子里的树

                A
              /  \
            B     C
          /  \
         D    E
       /  \
      F    G
          / \
         H  I

*/

/* 这里最开始想的是左右两边判断节点多少，节点多的就是深度高的，然后递归（循环）判断
深度深的那边的深度，但后来发现，节点多不一定更深，如果一边是单链，而另一边是满二叉树，
单链的那一边节点可能会少，但深度说不定会更深，所以最后还是老老实实用dfs对两边深度分别
求解，之后选择更深的一个加上本层的1做返回，直到最后返回到根节点时候，返回最终结果 */

#include <iostream>
#include <string>
using namespace std;

string preo, // 先序遍历序列
    ino;     // 中序遍历序列

/**
 * @brief dfs递归求解树的最大深度
 * 
 * @param pi 当前子树根节点在先序遍历中的位置
 * @param left 当前子树中序遍历在中序序列中范围的左边
 * @param right 当前子树中序遍历在中序序列中范围的右边
 * @return int 当前树的最大深度
 */
int calc(int pi = 0, int left = 0, int right = ino.size() - 1) {

    // 如果当前只有一个节点就直接返回1层
    if (right - left <= 0)
        return 1;

    char c = preo[pi];
    // 找到当前子树的先序遍历的根节点在中序遍历中的位置，从而区分中序遍历的左右两部分
    int idx = ino.find(c, left);

    /* 这里往左边走，对于先序遍历而言中间节点的位置只需要
    向后走一个就可以了，对于中序遍历而言，左子树的中序遍历
    就应该是先序遍历中间节点部分的左边，左边索引不变，而
    右边索引到中间节点往左边一个 */
    int x = calc(pi + 1, left, idx - 1); // 左子树的深度

    /* 这里和上面的原理也是一样 */
    int y = calc(pi + idx - left + 1, idx + 1, right); // 右子树的深度

    // 求出两边更深的高度，然后加上本层的1
    return 1 + (x > y ? x : y);
}

int main() {
    int N = 0;
    cin >> N;
    cin >> preo >> ino; // 这里输入的时候我受前面影响还getline，后来才反应过来直接输入就行了
    cout << calc();
    return 0;
}