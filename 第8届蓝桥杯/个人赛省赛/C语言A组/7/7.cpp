/*
描述：正则问题

考虑一种简单的正则表达式：
只由 x ( ) | 组成的正则表达式。
小明想求出这个正则表达式能接受的最长字符串的长度。  

例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6。

输入
----
一个由x()|组成的正则表达式。输入长度不超过100，保证合法。  

输出
----
这个正则表达式能接受的最长字符串的长度。  

例如，
输入：
((xx|xxx)x|(x|xx))xx  

程序应该输出：
6  

资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗  < 1000ms


请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

注意：
main函数需要返回0;
只使用ANSI C/ANSI C++ 标准;
不要调用依赖于编译环境或操作系统的特殊函数。
所有依赖的函数必须明确地在源文件中 #include <xxx>
不能通过工程设置而省略常用头文件。

提交程序时，注意选择所期望的语言类型和编译器类型。

*/

/*

很巧妙的递归解决，我没想到，参考的网上的程序写出来的，稍微修改了一下|情况下的给res赋值的部分。
主要的想法是碰到了括号就递归到一个新的函数之中，排除括号的干扰，计算纯粹括号内部表达式的值

*/

#include "iostream"
#include "string"
#include "algorithm"

//字符串
std::string str;
//当前游标和字符串长度
int pos = 0, len = 0;

//递归解决
int dfs()
{
    //这里的两个变量，考虑到有|操作，num是当前正在计算的x长度，res是计算完成之后的x的长度
    int num = 0, res = 0;
    //当字符串没有遍历完的话
    while (pos < len)
    {
        //如果是左括号，则递归，游标自加，主要是为了能够排除掉括号的干扰，用里面的纯表达式进行一次计算
        if (str[pos] == '(')
        {
            pos++;
            //这个地方是用num获取括号内部表达式的长度
            num += dfs();
        }
        //如果是右括号的话，则跳出去，说明这个括号内部的内容计算完毕了，可以返回了
        else if (str[pos] == ')')
        {
            pos++;
            break;
        }
        //如果是|符号的话，说明计算完了|左边的表达式，准备计算右边的表达式
        else if (str[pos] == '|')
        {
            pos++;
            //将计算完的左边的长度给res
            res = num;
            //num重置，准备计算右边的长度
            num = 0;
        }
        //否则说明这里是x，计算
        else
        {
            pos++;
            num++;
        }
    }
    //一般括号里面都是xxx..|xxx..这样的形式，所以res和num分别代表|两边的表达式长度，找长的返回
    return std::max(num, res);
}

int main()
{
    //输入
    std::cin >> str;
    //获取字符串长度
    len = str.size();
    //给出结果
    std::cout << dfs() << std::endl;

    return 0;
}