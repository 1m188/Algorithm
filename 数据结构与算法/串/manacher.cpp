/*

Manacher 算法  （马拉车算法）

求给定字符串中最大回文子串

一般求一个字符串最大回文子串的时候要么用中心扩展法（暴力）：从头开始遍历字符串，
对每个字符为中心向两边扩展，一直到无法相等的时候，此时得到一个回文串，找出所有
这种回文串中最长的那个。

要么用动态规划法。

这两种方法都是O(n^2)的复杂度，而manacher算法可以将这一过程降低至O(n)，它基于
中心扩展的暴力方法，但是在中心扩展的过程中利用了其计算出来的中间结果。一般在做
中心扩展的时候，有时候会得到一个较长的回文串，此时以该字符为中心两边有一些字符
是已经比较过了的，此时对下一个字符又重新开始比较实在有些可惜，于是将这些计算结
果利用起来，当然，实际使用的方法要复杂很多。

manacher算法基于中心扩展的暴力法进行优化，其基本流程还是基于遍历，然后中心扩展
的，只不过在每次中心扩展完了之后需要更新一些中间变量，中心扩展之前要利用这些变量
得到一个不用进行扩展的最少的长度，然后从这个最小长度继续往外进行扩展即可。

1. 对字符串进行预处理。

   字符串里字符的个数分为奇数个和偶数个，对于偶数个字符的时候，其对称中心在两个
   字符之间，不太好拿位置，所以将字符间填充一些特殊字符，只要在字符串中没有出现
   过的字符都可以作为特殊字符进行填充。字符 间 填充完字符后，要在字符首尾也加上
   特殊字符，此时，对于每个字符而言，其前面都有一个特殊字符，并且在最后一个字符
   的最后也有特殊字符，处理之后的字符串长度为 2*n+1 为一个奇数，方便计算。

2. 存储一些计算的中间结果。

   p[]数组，其长度和处理后的字符串一样，对于索引i，p[i]的含义是：在处理后的字符
   串中，以s[i]为中心的对称字符串的半径长度（或者说往两边扩展的字符数），比如说：
   对于字符串  s="aaabb"  而言，i为1，此时以s[i]为中心的最长回文串为"aaa"，那
   么p[i]==1，因为对于最中间的a而言不算，首先忽略，然后对于两边而言各扩展1个字
   符，那么就是1。

   r，在遍历的过程中会得到以每个字符为中心的最长回文串，这些子回文串有不同的有边
   界（其最右边的字符的索引），选择其中最大的一个，即为r。

   c，对于r而言，r所代表的回文串的中心字符索引，为c。

3. 计算。

   首先对于第一个字符没什么好说的，第一个字符无论如何其最长回文子串都只是他自己一
   个，那么此时最长回文子串就是他自己了，r=0（这个回文串最右边索引是0），c=0（使
   得r成立的回文串的中心字符的索引也是第一个字符，为0），p[0]=0（索引为0的字符向
   两边扩展0个字符，为0）。之后从索引为1的字符开始遍历，直到最后。

   对于每个字符而言，其索引为i：

   ① 如果i<r，则：p[i] = min(p[2 * c - i], r - i)
   ② 如果i>=r，则：p[i] = 0
   ③ 以p[i]为扩展半径，从 i + p[i] + 1 开始以 i 为对称中心进行比较，直到不相等
     或者超过字符串边界为止，更新最终的p[i]
   ④ 考察 i + p[i] > r? 如果成立，则更新r和c（r = i + p[i];c = i;）。

   解释一下第一步的操作：

   对于每一个字符而言，其索引会遇到两种情况， i < r 或 i >= r ，当 i < r 的时候，
   说明 i 在以 c 为中心的回文子串的内部，此时考察 i 以 c 为对称中心的另一个对称点 i' ，
   因为字符串从左往右遍历，此时 p[i'] 必然已经有了，其含义是以 i' 为中心的 最大的 回文
   子串其不包括 i' 的半径长度（就是从 i' 往左右两边扩展的字符数），如果 i + p[i'] < r，
   说明以 i' 为中心的最大回文子串也是包含在以 c 为中心的最大回文子串里面的，此时 i' 所代表
   的子串可以通过 c 对称过来，那么以 i 为中心的最大回文子串就不必再比较这个长度以内的部分了，
   可以直接从新的长度开始进行对称比较，这里也是类似动态规划的思想，每一步的计算都利用了前面
   保存的某种结果。如果 i + p[i'] >= r ,那么意味着以 i' 为中心的最大回文子串其左边界超过了
   以 c 为中心的最大回文子串的左边界，不在 c 以内了，那么超出的部分不能够再通过 c 对称过去了，
   于是 p[i] （以 i 为中心的最大回文子串的不包括i的半径）就只能从 r-i 开始（最大到边界部分），
   然后从这个基础再开始左右扩展。

   至于min，因为从上面的分析可知，i为中心的回文串的初始半径最长不能够超出r的范围，所以要么是
   p[i']，i + p[i']在r里面，那就是他p[i']，如果超出了，那么上限在r处，为r-i，无论怎么选，
   都是两者中较小者。p[i']更小，那么从i+p[i']到r的部分是未知的，如果r-i更小，说明p[i']+i
   超出界限了，于是只能取到到c回文串的边界。

   因为要尽可能的得到一个大的初始扩展半径，而由上面所知扩展半径尽可能的大就需要r尽可能的大，
   这样才能够尽可能的容忍 p[i'] 的半径长度，所以r要更新，始终选择最大的，并且要选择靠右的，
   如果c无法覆盖到新的扩展中心的话，那么意味着这个c已经没用了，顺带的，c也要更新。

   当i>r的时候，因为不在以 c 为中心的对称点里面，所以没办法对称过来（不在c里面未必对称），
   只好从0开始暴力。

   这个方法基于暴力中心扩展法，但其中有些地方能够借助于之前计算的结果半径，不必每次都从0开始，
   这也是其效率更高的地方。由于借助了之前计算的结果来得出后面的结果，也可以算作是一种动态规划。

4. 算法效率分析。

   空间复杂度毫无疑问是O(n)，因为要给原来的字符串加入同样长度还多1的特殊字符，并且还有一个p
   数组。但，时间复杂度是多少？

   如果单看算法形式的话，看似是O(n^2)，因为从头到尾遍历的字符串后，里面还有一个while循环，
   两层循环嘛。但仔细考察，这个while循环被执行的时候是什么时候？是r要被扩展的时候，当while循环
   达到O(n)的复杂度的时候，是r被扩展的时候，而r一旦被扩展，后面一直到r的边界部分的就都不必再
   while了，而r最多被扩展n次，此时在for循环里，每一次for都执行一次while（注意while里的循环只是
   执行一次，并不是说整个while执行一次），或者是在其中的某一次for里while执行了n次，此时r被扩展
   到边界，往后所有的for都不会执行while了，所以整体时间复杂度为O(n)。

*/

#include <cstdio>
#include <string>
#include <vector>
using namespace std;

/**
 * @brief manacher算法求给定字符串最长回文子串
 * @param s 待求解的母串
 * @return string 最长回文子串
 */
string manacher(string s) {

    // 特殊情况排除
    if (s.empty() || s.size() == 1)
        return s;

    // 预处理，在每个字符之间加入特殊字符（‘#’），
    // 在首尾加入特殊字符（‘#’），
    for (int i = 0; i < s.size(); i += 2)
        s.insert(i, "#");
    s.push_back('#');

    vector<int> p(s.size()); // p数组，存储字符串里i索引处字符为中心的最长回文子串的半径（不包括i）
    // 这里变量取0都是为了第一个元素考量，之后遍历直接从第二个字符开始
    p[0] = 0;  // 第一个字符初始化
    int r = 0; // 所有回文子串的右边界中的最大的一个
    int c = 0; // 最大右边界的中心字符

    // 遍历所有字符
    for (int i = 1; i < s.size(); i++) {

        // 两种情况判定，拿到初始扩展半径
        if (i < r) {
            p[i] = min(p[2 * c - i], r - i);
        } else {
            p[i] = 0;
        }

        // 从初始扩展半径往两边扩展
        while (i + p[i] + 1 < s.size() &&
               i - p[i] - 1 >= 0 &&
               s[i + p[i] + 1] == s[i - p[i] - 1])
            p[i]++;

        // 更新r和c
        if (i + p[i] > r) {
            r = i + p[i];
            c = i;
        }
    }

    // 拿到最长回文子串，注意去除特殊字符

    int idx = 0;
    for (int i = 0; i < p.size(); i++)
        if (p[i] > p[idx])
            idx = i;

    string ans = s.substr(idx - p[idx], p[idx] * 2 + 1);
    for (int i = 0; i < ans.size();)
        if (ans[i] == '#')
            ans.erase(i, 1);
        else
            i++;

    return ans;
}

int main() {

    printf("%s", manacher("Is PAT&TAP symmetric?").c_str()); // "s PAT&TAP s"

    return 0;
}