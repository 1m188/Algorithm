/*
问题描述
　　（图３.１－１）示出了一个数字三角形。 请编一个程序计算从顶至底的某处的一条路
　　径，使该路径所经过的数字的总和最大。
　　●每一步可沿左斜线向下或右斜线向下走；
　　●1＜三角形行数≤100；
　　●三角形中的数字为整数0，1，…99；


　　.
　　（图３.１－１）
输入格式
　　文件中首先读到的是三角形的行数。

　　接下来描述整个三角形
输出格式
　　最大总和（整数）
样例输入
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
样例输出
30
*/

//这道题目有点东西，一开始用的dfs暴力求解，但是最后三个测试点总是超时，于是上网查资料改成了这个动态规划
//其想法是对每一行输入，给出到这行为止的每个路径的最大值，一边输入一边计算

#include "iostream"
#include "vector"
#include "algorithm"

int main()
{
    int n = 0;
    std::cin >> n;
    std::vector<int> v(1, 0);

    for (int i = 0; i < n; i++)
    {
        //输入当前行的数据
        std::vector<int> t(i + 1, 0);
        for (int j = 0; j < i + 1; j++)
        {
            std::cin >> t[j];
        }

        //计算到新行这里每个路径的头尾的最大值
        t[0] += v[0];
        t.back() += v.back();

        //计算中间的最大值，这里注意因为有两条路径，所以每次选最大的
        //局部最优+动态规划
        for (int j = 1; j < t.size() - 1; j++)
        {
            t[j] += std::max(v[j], v[j - 1]);
        }

        //保存好新的路径最大值
        v.swap(t);
    }

    std::cout << *std::max_element(v.begin(), v.end());

    return 0;
}