#include "iostream"
int main() //巧妙的算法！
{
    int D = 0, I = 0;
    while (std::cin >> D >> I && !std::cin.eof()) //输入
    {
        int k = 1;                      //结点标号
        for (int i = 0; i < D - 1; i++) //对于一颗该二叉树上的每个结点，只有开或关两种情况，可以通过计算每层最后一个小球经过的结点在之前有多少个小球经过来判断这个结点在最后一个小球经过的时候是开还是关，从而避免了直接模拟导致的巨大开销
        {                               //层数
            if (I % 2)                  //如果小球为奇数
            {
                k *= 2;        //说明最后一个小球将要经过的本层结点为关闭的状态
                I = I / 2 + 1; //计算下一层往左走的小球数目
            }
            else
            {
                k = 2 * k + 1;   //...打开...
                I = (I + 1) / 2; //...往右走...
            }
        }
        std::cout << k << std::endl;
    }

    return 0;
}