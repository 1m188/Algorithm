/*
01-复杂度1 最大子列和问题 （20 分）
给定K个整数组成的序列{ N
​1
​​ , N
​2
​​ , ..., N
​K
​​  }，“连续子列”被定义为{ N
​i
​​ , N
​i+1
​​ , ..., N
​j
​​  }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。

本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：

数据1：与样例等价，测试基本正确性；
数据2：102个随机整数；
数据3：103个随机整数；
数据4：104个随机整数；
数据5：105个随机整数；
输入格式:

输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。

输出格式:

在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。

输入样例:

6
-2 11 -4 13 -5 -2
输出样例:

20
*/

//自己不会写...看了别人的思路才想通...真是巧妙...

//从头开始遍历，记录每个数字的和，如果这个和<=0，那么从后面的新的数开始重新计和，否则保留这个和，之后和预定的最大值比较大小，给出最大值
//重新计和的意思是说，如果有某段的和<=0了，那么之前的>0的和肯定是更优的解，但是每次会保留最大值，所以之前的最优解已经保存过了，从下一个
//>0的数开始计和，直到最终遍历完整个数组为止，而此时也保存了最大值。
//这种算法只有一个循环，复杂度在O(N)，所以很快

#include "iostream"
#include "vector"

int main()
{
    int K = 0;
    std::cin >> K;
    std::vector<int> vec(K);
    bool isAllNegative = true;
    for (int i = 0; i < K; i++)
    {
        std::cin >> vec[i];
        if (vec[i] >= 0)
        {
            isAllNegative = false;
        }
    }

    if (isAllNegative)
    {
        std::cout << 0;
    }
    else
    {
        int max = 0, sum = 0;
        for (int i = 0; i < K; i++)
        {
            //和<=0
            if (sum <= 0)
            {
                sum = vec[i];
            }
            //和>0，保留和
            else
            {
                sum += vec[i];
            }
            //给出最大值
            if (sum > max)
            {
                max = sum;
            }
        }
        std::cout << max;
    }

    return 0;
}