/*
7-5 堆中的路径 （25 分）
将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。

输入格式:

每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。

输出格式:

对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。

输入样例:

5 3
46 23 26 24 10
5 4 3
输出样例:

24 23 10
46 23 10
26 10
*/

//第一次接触堆这个数据结构，看了网上的思路才写出来，堆是一种完全二叉树的结构，其每个节点都不大于（大顶堆）或者不小于（小顶堆）其父节点，这个题目是小顶堆
//用从1开始的索引来做数组，0的部分用一个最小的数来填，这样可以支持插入第一个数据，也方便直接用下标来插入或者获取数据，且数组只需做出规定：下标越小的越接
//近左边的树，那么用数组来做堆便天然的具有完全二叉树的结构

#include "iostream"
#include "vector"

//堆数组
std::vector<int> heap;
//新的空位用来插入数据或者是将大的数据向后移动
int index = 1;

//将数据插入堆中，这里用的方法是我从网上看到的，很巧妙
void insert(int num)
{
    int i = 0;
    //这里的意思是，每个下标除以2其实是他的父节点的下标，那么从最开始走的话，只要当前节点的父节点的大小大于待插入数据
    //那么就将父节点放到当前的地方，其实就是向后移动了一下，变成了原来的子节点，然后索引自己/=2是为了找到更上面一个父节点
    for (i = index; heap[i / 2] > num; i /= 2)
    {
        heap[i] = heap[i / 2];
    }
    //最后找到了某个地方的父节点是小于待插入数据的，那么这个数据 就插入到当前位置
    heap[i] = num;
    //堆的末端索引自加，为了给新的插入数据腾出位置，或者是给大了的数据向后移动腾出位置
    index++;
}

int main()
{
    int N = 0, M = 0;
    std::cin >> N >> M;
    heap.resize(N + 1);
    heap[0] = -10001;
    for (int i = 0; i < N; i++)
    {
        int temp = 0;
        std::cin >> temp;
        insert(temp);
    }

    for (int i = 0; i < M; i++)
    {
        int ii = 0;
        std::cin >> ii;
        //这个地方从下标处往根节点的路径，每往父节点走一次，索引就/=2
        for (int j = ii; j >= 1; j /= 2)
        {
            std::cout << heap[j];
            if (j != 1)
            {
                std::cout << ' ';
            }
        }
        std::cout << std::endl;
    }

    return 0;
}