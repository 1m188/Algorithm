/*
问题描述
　　题目很简单，给出N个数字，不改变它们的相对位置，在中间加入K个乘号和N-K-1个加号，（括号随便加）使最终结果尽量大。因为乘号和加号一共就是N-1个了，所以恰好每两个相邻数字之间都有一个符号。例如：
　　N=5，K=2，5个数字分别为1、2、3、4、5，可以加成：
　　1*2*(3+4+5)=24
　　1*(2+3)*(4+5)=45
　　(1*2+3)*(4+5)=45
　　……
输入格式
　　输入文件共有二行，第一行为两个有空格隔开的整数，表示N和K，其中（2<=N<=15, 0<=K<=N-1）。第二行为 N个用空格隔开的数字（每个数字在0到9之间）。
输出格式
　　输出文件仅一行包含一个整数，表示要求的最大的结果
样例输入
5 2
1 2 3 4 5
样例输出
120
样例说明
　　(1+2+3)*4*5=120
*/

//题目说要用动态规划，然后查了一下动态规划的相关内容，各种状态转移方程，无后效性等等，虽然大概能够理解，但是放到
//具体的题目中就不知道该怎么做了，上网看了一下别人的思路，学习一下
//关于动规，可以看看：https://www.zhihu.com/question/23995189

//别人思路：
//本题采用动态规划算法，不要考虑括号，只从乘号来考虑，设dp[i][j]表示，i个元素里有j个乘号时算式的最大值。
//sum[i]表示前i个元素的和。

//因此动态规划状态转移方程为：dp[i][j]=max(dp[i][j]，dp[l-1][j-1]*(sum[i]-sum[l-1]])，
//思路：假设最后一个乘号出现在第L个元素之前，
//所以问题就转化为了求前L-1个数加j-1个乘号最大的算式值载乘上第L个元素到第i个元素的和，
//而L-1个元素加j-1个乘号又可以按相同的方法分解为更小的子问题。
//只要找出一个l使得最后一个乘号出现在这个位置上时的值最大，就可以存入dp[i][j]中。

#include "iostream"
#include "vector"
#include "algorithm"

int main()
{
    int N = 0, K = 0;
    std::cin >> N >> K;
    std::vector<std::vector<long long>> dp(N + 1, std::vector<long long>(N + 1, 0)); //这里没说数据规模，所以用的long long
    std::vector<long long> sum(N + 1, 0);

    //输入
    for (int i = 1; i <= N; i++)
    {
        int x = 0;
        std::cin >> x;
        sum[i] = sum[i - 1] + x; //前i个元素的和
        dp[i][0] = sum[i];       //初始化，如果没有乘号，那么最大的算式即为和
    }

    //动规计算
    //自顶向下计算前i个元素的算式最大值，注意从2开始元素至少有2个
    for (int i = 2; i <= N; i++)
    {
        int k = std::min(i - 1, K); //约束前i个元素最多有i-1个乘号，但是乘号最多也不能够超过K

        //乘号的个数
        for (int j = 1; j <= k; j++)
        {
            //最后一个乘号的位置，注意从2开始
            for (int l = 2; l <= i; l++)
            {
                //在所有最后一个乘号的位置的枚举中，找出使得算式值最大的那一个
                dp[i][j] = std::max(dp[i][j], dp[l - 1][j - 1] * (sum[i] - sum[l - 1]));
            }
        }
    }

    std::cout << dp[N][K];

    return 0;
}