#
# @lc app=leetcode.cn id=91 lang=python3
#
# [91] 解码方法
#
# https://leetcode-cn.com/problems/decode-ways/description/
#
# algorithms
# Medium (32.06%)
# Likes:    1180
# Dislikes: 0
# Total Accepted:    216.1K
# Total Submissions: 671.1K
# Testcase Example:  '"12"'
#
# 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
#
#
# 'A' -> "1"
# 'B' -> "2"
# ...
# 'Z' -> "26"
#
# 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
#
#
# "AAJF" ，将消息分组为 (1 1 10 6)
# "KJF" ，将消息分组为 (11 10 6)
#
#
# 注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
#
# 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
#
# 题目数据保证答案肯定是一个 32 位 的整数。
#
#
#
# 示例 1：
#
#
# 输入：s = "12"
# 输出：2
# 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
#
#
# 示例 2：
#
#
# 输入：s = "226"
# 输出：3
# 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
#
#
# 示例 3：
#
#
# 输入：s = "0"
# 输出：0
# 解释：没有字符映射到以 0 开头的数字。
# 含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
# 由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
#
#
#
#
# 提示：
#
#
# 1 <= s.length <= 100
# s 只包含数字，并且可能包含前导零。
#
#
#
'''
动态规划

考虑dp[][],假设

dp[0][i]为i索引处字符单独解释且以其结尾的字符串最大解释数目
dp[1][i]为i索引处字符和i-1处字符联合解释且以其结尾的字符串最大解释数目
则整个字符串解释数目：dp[0][dp[0].size - 1] + dp[1][dp[1].size - 1]

且有递推方程：

如果i处字符可以单独解释，dp[0][i] = dp[0][i - 1] + dp[1][i - 1] 否则 0

如果i处字符可以和前面的字符联合解释，dp[1][i] = dp[0][i - 2] + dp[1][i - 2] 否则 0
'''


# @lc code=start
class Solution:

    def numDecodings(self, s: str) -> int:

        dp = [[0 for _ in range(len(s))] for _ in range(2)]

        dp[0][0] = 1 if s[0] != '0' else 0  # 考虑前导0
        dp[1][0] = 0  # 前面没有数字，不能够联合解释

        for i in range(1, len(s)):

            dp[0][i] = dp[0][i - 1] + dp[1][i - 1] if s[i] != '0' else 0

            x = int(s[i - 1]) * 10 + int(s[i])
            if 10 <= x <= 26:
                # 记得考虑第2个字符的位置
                dp[1][i] = dp[0][i - 2] + dp[1][i - 2] if i - 2 >= 0 else 1
            else:
                dp[1][i] = 0

        return dp[0][-1] + dp[1][-1]


# @lc code=end
