'''
描述
给定一个由节点值从 1 到 n 的 n 个节点。请问由多少种不同的方法用这 n 个节点构成互不相同的二叉搜索树。

数据范围： 1 \le n \le 19 \1≤n≤19 
输入描述：
仅一行输入一个正整数 n ，表示节点的数量。
输出描述：
输出组成不同二叉搜索树的方法数。
示例1
输入：
3
复制
输出：
5
复制
示例2
输入：
2
复制
输出：
2
'''
'''
动态规划

基本思想是，对于一个节点i，其值也为i，那么比i小的节点放左边，比i大的节点放右边，对于两边也是同样，
那么到最后直到为空或者为单个节点等易于处理的情况

很容易能够想到递归的想法，但是耗时太大，当n=19的时候就很慢了，发现这个思想基本上还是将
多的节点的情况分解为少节点的简单情况，即，后续的结果依赖于前面的结果，于是引入动态规划

dp[i] = dp[i_left] * dp[i_right]

dp[i]指当根节点为i的时候的二叉搜索树总数，i_left指比i小的节点数，i_right指比i大的节点数，
二者dp的乘积为dp[i]，并且，对于n个节点，i要从1到n取和才行，得到最终的结果

依次递增，直到达到最终的结果
'''

n = int(input())
dp = [0 for _ in range(n + 1)]
dp[0] = dp[1] = 1

for i in range(2, n + 1):
    for j in range(1, i + 1):
        dp[i] += dp[j - 1] * dp[i - j]

print(dp[n])
