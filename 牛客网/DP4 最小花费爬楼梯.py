'''
描述
给定一个整数数组 cost \cost  ，其中 cost[i]\cost[i]  是从楼梯第i \i 个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

数据范围：数组长度满足 1 \le n \le 10^5 \1≤n≤10 
5
   ，数组中的值满足 1 \le cost_i \le 10^4 \1≤cost 
i
​
 ≤10 
4
  
输入描述：
第一行输入一个正整数 n ，表示数组 cost 的长度。
第二行输入 n 个正整数，表示数组 cost 的值。
输出描述：
输出最低花费
示例1
输入：
3
2 5 20
复制
输出：
5
复制
说明：
你将从下标为1的台阶开始，支付5 ，向上爬两个台阶，到达楼梯顶部。总花费为5 
示例2
输入：
10
1 100 1 1 1 90 1 1 80 1
复制
输出：
6
复制
说明：

你将从下标为 0 的台阶开始。
1.支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
2.支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
3.支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
4.支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
5.支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
6.支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。     
'''
'''
动态规划
dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])

其中，dp[i]代表到第i阶楼梯的最小花费值，其要么从前一级台阶向上走，要么
从前两级台阶向上走，取最小的

这里能够从0和1两个楼梯出发，因此用两个dp，求最终的最小值

需要注意的是，因为是走到楼梯顶部，所以dp数组要比cost数组长度多1，最后
一个地方为最后一级楼梯之后的楼梯，或者说，楼梯顶部

最后，注意不能够从下标为1的台阶出发的情况，即整个楼梯只有1级的时候
'''

n = int(input())
cost = list(map(int, input().split()))

dp0 = [0 for _ in range(n + 1)]
dp0[0] = 0
dp0[1] = cost[0]
for i in range(2, n + 1):
    dp0[i] = min(dp0[i - 1] + cost[i - 1], dp0[i - 2] + cost[i - 2])

if n > 1:  # 如果只有一级楼梯就不能够从下标为1的阶梯向上爬

    dp1 = [0 for _ in range(n + 1)]
    dp1[1] = 0
    dp1[2] = cost[1]
    for i in range(3, n + 1):
        dp1[i] = min(dp1[i - 1] + cost[i - 1], dp1[i - 2] + cost[i - 2])

    print(min(dp0[-1], dp1[-1]))

else:
    print(dp0[-1])
