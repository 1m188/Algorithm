/**
 * @file JZ46 把数字翻译成字符串.cpp
 * @date 2022-05-28
 */

/*
描述
有一种将字母编码成数字的方式：'a'->1, 'b->2', ... , 'z->26'。
我们把一个字符串编码成一串数字，再考虑逆向编译成字符串。
由于没有分隔符，数字编码成字母可能有多种编译结果，例如 11 既可以看做是两个 'a' 也可以看做是一个 'k' 。但 10 只可能是 'j' ，因为 0 不能编译成任何结果。
现在给一串数字，返回有多少种可能的译码结果

数据范围：字符串长度满足 0 < n \le 900<n≤90
进阶：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
示例1
输入：
"12"
复制
返回值：
2
复制
说明：
2种可能的译码结果（”ab” 或”l”）     
示例2
输入：
"31717126241541717"
复制
返回值：
192
复制
说明：
192种可能的译码结果
*/

/* 动态规划

每个数字只有两种解释方式：
1. 自己单独解释
2. 和前面的数字共同解释

考虑dp[][]数组为一个二维数组
dp[0][i]为i索引处的数字字符能够单独解释时以其为结尾的字符串最多解释方式数目
dp[1][i]为i索引处的数字字符能够和前面的数字联合解释时候以其为结尾的字符串的最多解释数目

则在i索引处数字字符为结尾的字符串最多解释数目为 dp[0][i] + dp[1][i]

当其能够单独解释时有 dp[0][i] = dp[0][i-1] + dp[1][i-1] 否则 0
当其能够和前面的数字联合解释的时候有 dp[1][i] = dp[0][i-2] + dp[1][i-2] 否则 0 */

#include <string>
#include <vector>
using namespace std;

class Solution {
  public:
    /**
     * 解码
     * @param nums string字符串 数字串
     * @return int整型
     */
    int solve(string nums) {
        // write code here

        vector<vector<int>> dp(2, vector<int>(nums.size()));

        dp[0][0] = 1; // 第一个字符单独解释（不为0，输入数字字符串必须合法）
        dp[1][0] = 0; // 第一个字符前面没有其他数字，不能联合解释

        // 从第2个字符开始
        for (int i = 1; i < nums.size(); i++) {

            // 能否单独解释？
            dp[0][i] = nums[i] == '0' ? 0 : dp[0][i - 1] + dp[1][i - 1];

            // 能否和前一个字符联合解释？
            int x = (nums[i - 1] - '0') * 10 + nums[i] - '0';
            if (x >= 10 && x <= 26)
                // 如果i-2<0的话说明刚好是第2个字符，只有一种
                dp[1][i] = i - 2 >= 0 ? dp[0][i - 2] + dp[1][i - 2] : 1;
            else
                dp[1][i] = 0;
        }

        // 到最后一个字符的两种解释方式之和为最终结果
        return dp[0].back() + dp[1].back();
    }
};