/*
描述

假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，
返回买卖股票能获得的最大收益

1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，
且买入必须在卖出的前面的某一天

2.如果不能获取到任何利润，请返回0

3.假设买入卖出均无手续费

数据范围： 0≤n≤10^5,0≤val≤10^4
 
要求：空间复杂度 O(1)，时间复杂度 O(n)

示例1
输入：
[8,9,2,5,4,7,1]

返回值：
5

说明：
在第3天(股票价格 = 2)的时候买入，在第6天(股票价格 = 7)的时候卖出，最大利润 = 7-2 = 5 ，不能选择在第2天买入，
第3天卖出，这样就亏损7了；同时，你也不能在买入前卖出股票。   

示例2
输入：
[2,4,1]

返回值：
2

示例3
输入：
[3,2,1]

返回值：
0
*/

#include <algorithm>
#include <vector>

using namespace std;

/*
使用动态规划解决

考虑动态规划数组dp[i][j]，j=0时为第i天不持股，j=1时为第i天持股

初始时不持股时候手中现金为0，持股时手中现金为-prices[0]

有转移方程
dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
dp[i][1] = max(dp[i - 1][1], -prices[i])

最终返回不持股时候的现金，即dp[dp.size()-1][0]
*/
class Solution
{
public:
    /**
     * 
     * @param prices int整型vector 
     * @return int整型
     */
    int maxProfit(vector<int> &prices)
    {
        // write code here

        // 动态规划数组
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][1] = -prices[0]; // 最开始持股的时候是第一天的股价买入

        // 更新dp数组
        for (int i = 1; i < dp.size(); i++)
        {
            // 今天不持股有两种情况
            // 1. 昨天不持股
            // 2. 昨天持股
            // 对1而言，不变
            // 对2而言，卖出去了
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);

            // 今天持股有两种情况
            // 1. 昨天不持股
            // 2. 昨天持股
            // 对1而言，买入了，但由于只能够买入一次，所以这里的情况
            // 一定是0-今天的股价
            // 对2而言，不变
            dp[i][1] = max(dp[i - 1][1], -prices[i]);
        }

        // 返回最后一天不持股的情况
        // 因为股票总要卖出去，这一天再不卖就不能卖了
        // 而且总共要买入卖出一次
        return dp[dp.size() - 1][0];
    }
};