'''
描述
你是一个经验丰富的小偷，准备偷沿湖的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家，如果偷了第二家，那么就不能偷第一家和第三家。沿湖的房间组成一个闭合的圆形，即第一个房间和最后一个房间视为相邻。
给定一个长度为n的整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。

数据范围：数组长度满足 
1
≤
n
≤
2
×
1
0
5
 
1≤n≤2×10 
5
  ，数组中每个值满足 
1
≤
n
u
m
s
[
i
]
≤
5000
 
1≤nums[i]≤5000 
示例1
输入：
[1,2,3,4]
复制
返回值：
6
复制
说明：
最优方案是偷第 2 4 个房间      
示例2
输入：
[1,3,6]
复制
返回值：
6
复制
说明：
由于 1 和 3 是相邻的，因此最优方案是偷第 3 个房间 
'''

from typing import List


#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
#
# @param nums int整型一维数组
# @return int整型
#
class Solution:

    def rob(self, nums: List[int]) -> int:
        # write code here

        n = len(nums)
        dp0 = [[0, 0] for _ in range(n)]
        dp1 = [[0, 0] for _ in range(n)]
        dp1[0][0] = dp1[0][1] = dp1[1][0] = dp1[1][1] = nums[0]

        for i in range(1, n):
            dp0[i][0] = max(dp0[i - 1][0], dp0[i - 1][1])
            dp0[i][1] = dp0[i - 1][0] + nums[i]

        for i in range(2, n):
            dp1[i][0] = max(dp1[i - 1][0], dp1[i - 1][1])
            dp1[i][1] = dp1[i - 1][0] + nums[i]

        return max(dp0[-1][0], dp0[-1][1], dp1[-1][0])
