/**
 * @file 202109-1 数组推导.cpp
 * @date 2022-08-26
 */

/*
试题编号：	202109-1
试题名称：	数组推导
时间限制：	1.0s
内存限制：	512.0MB
问题描述：	
题目描述
 是一个由  个自然数（即非负整数）组成的数组。在此基础上，我们用数组  表示  的前缀最大值。

如上所示， 定义为数组  中前  个数的最大值。
根据该定义易知 ，且随着  的增大， 单调不降。
此外，我们用  表示数组  中  个数的总和。

现已知数组 ，我们想要根据  的值来反推数组 。
显然，对于给定的 ， 的取值可能并不唯一。
试计算，在数组  所有可能的取值情况中， 的最大值和最小值分别是多少？

输入格式
从标准输入读入数据。

输入的第一行包含一个正整数 。

输入的第二行包含  个用空格分隔的自然数 。

输出格式
输出到标准输出。

输出共两行。

第一行输出一个整数，表示  的最大值。

第二行输出一个整数，表示  的最小值。

样例1输入
6
0 0 5 5 10 10
Data
样例1输出
30
15
Data
样例1解释
数组  的可能取值包括但不限于以下三种情况。

情况一：

情况二：

情况三：

其中第一种情况  为最大值，第三种情况  为最小值。

样例2输入
7
10 20 30 40 50 60 75
Data
样例2输出
285
285
Data
样例2解释
 是唯一可能的取值，所以  的最大、最小值均为 。

子任务
 的测试数据满足数组  单调递增，即 ；

全部的测试数据满足  且数组  单调不降，即 。
*/

/* 最大值要使得每一个元素都尽可能的大，但最大不能超过b数组里的值

最小值要求每个元素都尽可能的小，如果b中的一个元素比前面的更大的话
就说明这里引入了新的最大值，否则可以假设这个地方的元素为0，从而尽可能
的让和变小 */

#include <cstdio>
#include <vector>
using namespace std;

int n = 0;
vector<int> bvec;

int main() {

    scanf("%d", &n);
    bvec.resize(n);
    for (int i = 0; i < n; i++)
        scanf("%d", &bvec[i]);

    int max_sum = bvec[0], min_sum = bvec[0];

    for (int i = 1; i < n; i++) {
        if (bvec[i] > bvec[i - 1]) min_sum += bvec[i];
        max_sum += bvec[i];
    }

    printf("%d\n%d", max_sum, min_sum);

    return 0;
}