'''
问题描述
试题编号：	202112-2
试题名称：	序列查询新解
时间限制：	1.0s
内存限制：	512.0MB
问题描述：	
题目背景
上一题“序列查询”中说道：
 是一个由 
 个 
 范围内整数组成的序列，满足 
。基于序列 
，对于 
 范围内任意的整数 
，查询 
 定义为：序列 
 中小于等于 
 的整数里最大的数的下标。

对于给定的序列 
 和整数 
，查询 
 是一个很经典的问题，可以使用二分搜索在 
 的时间复杂度内轻松解决。但在 IT 部门讨论如何实现这一功能时，小 P 同学提出了些新的想法。

题目描述
小 P 同学认为，如果事先知道了序列 
 中整数的分布情况，就能直接估计出其中小于等于 
 的最大整数的大致位置。接着从这一估计位置开始线性查找，锁定 
。如果估计得足够准确，线性查找的时间开销可能比二分查找算法更小。

比如说，如果 
 均匀分布在 
 的区间，那么就可以估算出：
 

为了方便计算，小 P 首先定义了比例系数 
 
，其中 
 表示下取整，即 
 等于 
 除以 
 的商。进一步地，小 P 用 
 
 表示自己估算出的 
 的大小，这里同样使用了下取整来保证 
 是一个整数。

显然，对于任意的询问 
，
 和 
 越接近则说明小 P 的估计越准确，后续进行线性查找的时间开销也越小。因此，小 P 用两者差的绝对值 
 来表示处理询问 
 时的误差。

为了整体评估小 P 同学提出的方法在序列 
 上的表现，试计算：
 

输入格式
从标准输入读入数据。

输入的第一行包含空格分隔的两个正整数 
 和 
。

输入的第二行包含 
 个用空格分隔的整数 
。

注意 
 固定为 
，因此输入数据中不包括 
。

输出格式
输出到标准输出。

仅输出一个整数，表示 
 的值。

样例1输入
3 10
2 5 8
Data
样例1输出
5
Data
样例1解释

 
 

样例2输入
9 10
1 2 3 4 5 6 7 8 9
Data
样例2输出
0
Data
样例3输入
2 10
1 3
Data
样例3输出
6
Data
样例3解释

 
 

子任务
 的测试数据满足 
 且 
；

全部的测试数据满足 
 且 
。

提示
需要注意，输入数据 
 并不一定均匀分布在 
 区间，因此总误差 
 可能很大。
'''

# 70分代码，运行超时
# 看网上的思路，似乎应该遍历f(i)而不是i本身

n, N = map(int, input().split())
A = list(map(int, input().split()))
A.insert(0, 0)
A.append(N)
r = N // (n + 1)
errorA = 0
fidx = 1

for i in range(N):
    gi = i // r
    if i >= A[fidx]: fidx += 1
    fi = fidx - 1
    errorA += abs(gi - fi)

print(errorA)
