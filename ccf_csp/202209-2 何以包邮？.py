'''
问题描述
试题编号：	202209-2
试题名称：	何以包邮？
时间限制：	1.0s
内存限制：	512.0MB
问题描述：	
题目描述
新学期伊始，适逢顿顿书城有购书满 
 元包邮的活动，小 P 同学欣然前往准备买些参考书。
一番浏览后，小 P 初步筛选出 
 本书加入购物车中，其中第 
 本（
）的价格为 
 元。
考虑到预算有限，在最终付款前小 P 决定再从购物车中删去几本书（也可以不删），使得剩余图书的价格总和 
 在满足包邮条件（
）的前提下最小。

试帮助小 P 计算，最终选购哪些书可以在凑够 
 元包邮的前提下花费最小？

输入格式
从标准输入读入数据。

输入的第一行包含空格分隔的两个正整数 
 和 
，分别表示购物车中图书数量和包邮条件。

接下来输入 
 行，其中第 
 行（
）仅包含一个正整数 
，表示购物车中第 
 本书的价格。输入数据保证 
 本书的价格总和不小于 
。

输出格式
输出到标准输出。

仅输出一个正整数，表示在满足包邮条件下的最小花费。

样例1输入
4 100
20
90
60
60
Data
样例1输出
110
Data
样例1解释
购买前两本书（
）即可包邮且花费最小。

样例2输入
3 30
15
40
30
Data
样例2输出
30
Data
样例2解释
仅购买第三本书恰好可以满足包邮条件。

样例3输入
2 90
50
50
Data
样例3输出
100
Data
样例3解释
必须全部购买才能包邮。

子任务
 的测试数据满足：
；

全部的测试数据满足：
，每本书的价格 
 且 
。

提示
对于 
 的测试数据，直接枚举所有可能的情况即可。
'''
'''
本题其实是一个动态规划的背包问题
从所有书中挑选出一些书，使其价格之和达到最大，但最后有一个保底价格，假设所有书的价格
之和为sum，保底包邮的价格为x，则sum-x为删除书的价格的最大值，而我又需要删除书的价格
之和尽可能的大，换言之，我现在的背包容量为sum-x，书的重量和其价值相等，所以一方面我
要尽可能多的装书，一方面又不能够让书的容量超过我的背包容量，从而转化为一个01背包问题，
这其中的关键在于两点：
1. 认识到sum-x为一个背包的容量，为一个上限值
2. 书的价值和其重量相等
'''

n, x = map(int, input().split())
a = [0]
for _ in range(n):
    a.append(int(input()))
c = sum(a) - x

dp = [[0 for _ in range(c + 1)] for _ in range(n + 1)]
for i in range(1, n + 1):
    for j in range(1, c + 1):
        if j >= a[i]: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - a[i]] + a[i])
        else: dp[i][j] = dp[i - 1][j]

print(c + x - dp[n][c])  # c+x得出sum(a)，不必再求一遍
