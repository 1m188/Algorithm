'''
问题描述
试题编号：	202206-2
试题名称：	寻宝！大冒险！
时间限制：	500ms
内存限制：	512.0MB
问题描述：	
题目背景
暑假要到了。可惜由于种种原因，小 P 原本的出游计划取消。失望的小 P 只能留在西西艾弗岛上度过一个略显单调的假期……直到……

某天，小 P 获得了一张神秘的藏宝图。

问题描述
西西艾弗岛上种有 
 棵树，这些树的具体位置记录在一张绿化图上。
简单地说，西西艾弗岛绿化图可以视作一个大小为 
 的 
 矩阵 
，
地图左下角（坐标 
）和右上角（坐标 
）分别对应 
 和 
。
其中 
 表示坐标 
 处种有一棵树，
 则表示坐标 
 处没有树。
换言之，矩阵 
 中有且仅有的 
 个 
 展示了西西艾弗岛上 
 棵树的具体位置。

传说，大冒险家顿顿的宝藏就埋藏在某棵树下。
并且，顿顿还从西西艾弗岛的绿化图上剪下了一小块，制作成藏宝图指示其位置。
具体来说，藏宝图可以看作一个大小为 
 的 
 矩阵 
（
 远小于 
），对应着 
 中的某一部分。
理论上，绿化图 
 中存在着一处坐标 
（
）与藏宝图 
 左下角 
 相对应，即满足：
对 
 上任意一处坐标 
（
），都有 
。
当上述条件满足时，我们就认为藏宝图 
 对应着绿化图 
 中左下角为 
、右上角为 
 的区域。

实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 
 很可能存在多个。
请结合西西艾弗岛绿化图中 
 棵树的位置，以及小 
 手中的藏宝图，判断绿化图中有多少处坐标满足条件。

特别地，藏宝图左下角位置一定是一棵树，即 
，表示了宝藏埋藏的位置。

输入格式
从标准输入读入数据。

输入的第一行包含空格分隔的三个正整数 
、
 和 
，分别表示西西艾弗岛上树的棵数、绿化图和藏宝图的大小。

由于绿化图尺寸过大，输入数据中仅包含 
 棵树的坐标而非完整的地图；即接下来 
 行每行包含空格分隔的两个整数 
 和 
，表示一棵树的坐标，满足 
 且同一坐标不会重复出现。

最后 
 行输入小 P 手中完整的藏宝图，其中第 
 行（
）包含空格分隔的 
 个 
 和 
，表示 
。
需要注意，最先输入的是 
 一行，
 一行最后输入。

输出格式
输出到标准输出。

输出一个整数，表示绿化图中有多少处坐标可以与藏宝图左下角对应，即可能埋藏着顿顿的宝藏。

样例 1 输入
5 100 2
0 0
1 1
2 2
3 3
4 4
0 0 1
0 1 0
1 0 0
Data
样例 1 输出
3
Data
样例 1 解释
绿化图上 
、
 和 
 三处均可能埋有宝藏。

样例 2 输入
5 4 2
0 0
1 1
2 2
3 3
4 4
0 0 0
0 1 0
1 0 0
Data
样例 2 输出
0
Data
样例 2 解释
如果将藏宝图左下角与绿化图 
 处对应，则藏宝图右上角会超出绿化图边界，对应不成功。

子任务
 的测试数据满足：
；

 的测试数据满足：
；

全部的测试数据满足：
、
 且 
。

提示
实际测试数据中不包括答案为 
 的用例。
'''

n, L, S = map(int, input().split())
trees = set()  # 使用set更快判断是否在里面
for _ in range(n):
    x, y = map(int, input().split())
    trees.add((x, y))
B = [[0 for _ in range(S + 1)] for _ in range(S + 1)]
for i in range(S + 1):
    B[i] = list(map(int, input().split()))
B.reverse()  # 这里翻转为了适应(0,0)坐标在左下角的坐标系
res = 0

for x, y in trees:
    if not (0 <= x <= L - S and 0 <= y <= L - S): continue
    f = True
    for i in range(S + 1):
        for j in range(S + 1):
            # 不仅要测试1是否吻合，还要测试0是否吻合
            if (B[i][j] == 1 and (x + i, y + j) not in trees) or \
               (B[i][j] == 0 and (x + i, y + j) in trees):
                f = False
                break
    if f: res += 1

print(res)
